#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

#include "../z80/z80commands.h"

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  

#define MAXSPRITES  256
typedef struct {
    WORD    x;          // Sprite x position
    WORD    y;          // Sprite y position
    WORD    tile;       // Sprite tile
    
    // 0..4 CB[0..4] Palette ID used to render the tile
    // 5 X Flip Mirrored horizontally
    // 6 Y Flip Mirrored vertically
    // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
    // 8..11 XB[0..3] Horizontal size in tiles
    // 12..15 YB[0..3] Vertical size in tiles
    WORD    attributes;     // Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

#define Z80_CMD *((volatile BYTE*)0x800181)
#define Z80_PRM *((volatile BYTE*)0x800189)

void sendZ80(BYTE cmd) {
    Z80_CMD = cmd;
}

void sendZ80Param(BYTE cmd, BYTE param) {
    Z80_CMD = cmd;
    Z80_PRM = param;
}

CPSA_REG volatile WORD cpsa_reg[0x20] = {};
CPSB_REG volatile WORD cpsb_reg[0x20] = {};

/* Init called before "main" (run) */

void hardwareInit() {
    sendZ80(Z80_NO_OP);

    cpsa_reg[CPSA_REG_SCROLL1_SCROLLX] = 0x0000;
    cpsa_reg[CPSA_REG_SCROLL1_SCROLLY] = 0x0000;
    cpsa_reg[CPSA_REG_SPRITES_BASE] = 0x9100;
    cpsa_reg[CPSA_REG_SCROLL1_BASE] = 0x90c0;
    cpsa_reg[CPSA_REG_SCROLL2_BASE] = 0x9040;
    cpsa_reg[CPSA_REG_SCROLL3_BASE] = 0x9080;
    cpsa_reg[CPSA_REG_OTHER_BASE] = 0x9200;

    cpsb_reg[CPSB_REG_CTRL] = 0x12c2;
    cpsa_reg[CPSA_REG_VIDEOCONTROL] = 0x003e;
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] = 0x003f;
    cpsa_reg[CPSA_REG_PALETTE_BASE] = 0x9000;
}

void setPalette(int page, int paletteID, const Palette* palette) {

    for (int j = 0 ; j < 16 ; j++) {
        palettes[paletteID].colors[j] = (*palette).colors[j];
    }
    
    // Request upload palette page to sprites
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] =  1;
    
    // Set palette base
    cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

static const Palette p = {0xF111,0xFFD9,0xFFB9,0xFE97,0xFC86,0xF965,0xF643,0xFB00,0xFFFF,0xFEEC,0xFDCA,0xFBA8,0xFA87,0xF765,0xFF00,0x0000,};


void draw(WORD x,WORD y, BYTE flip) {
    setPalette(0, 2, &p); // Upload palette to Palette 2
    Sprite* s = &sprites[0];
    s->x = x;
    s->y = y;
    s->tile = 4;
    s->attributes = 2 |  5 << 12 | 3 << 8 | flip; // user Palette 2 since it is where we placed it.
    
    sprites[1].attributes = 0xFF00; // Last sprite marker
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);
}

void clearSprites() {
    sprites[0].attributes = 0xFF00; // Last sprite marker
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);
}


/* inputs */

#define _PLAYER_INPUTS_ADDR  0x800000
#define PLAYER_INPUTS *((volatile WORD*)_PLAYER_INPUTS_ADDR)

BYTE player1 = 0;
BYTE player2 = 0;
BYTE player1buf = 0;
BYTE player2buf = 0;
BYTE pressedp1 = 0;
BYTE pressedp2 = 0;

#define D_RIGHT     0x01
#define D_LEFT      0x02
#define D_DOWN      0x04
#define D_UP        0x08
#define BUTTON_1    0x10
#define BUTTON_2    0x20
#define BUTTON_3    0x40

void readJoysticks() {
    WORD inputs = 0;

    inputs = ~(PLAYER_INPUTS);
    player1 = inputs & 0x00FF;
    pressedp1 = player1 & ~player1buf;
    player1buf = player1;

    player2 = (inputs >> 8) & 0x00FF;
    pressedp2 = player2 & ~player2buf;
    player2buf = player2;
}

/* Vsync handler */
volatile WORD vsyncActive = 0;

void onVSync() {
    vsyncActive = 1;
    readJoysticks();
}

void waitVsync() {
    while(vsyncActive == 0);
    vsyncActive = 0;
}

/* MDF functions */

#define MDF_ADPCM_NORM  0
#define MDF_ADPCM_LONG  1

void ExecutePulseTrain()
{
    WORD f = 0;
    //Sync

    for(f = 0; f < 10; f++) {
        sendZ80(Z80_PULSE_ON);
        waitVsync();
        sendZ80(Z80_PULSE_OFF);
        waitVsync();
    }
}

void WaitFrames(WORD frames)
{
    WORD frame = 0;
    
    //Silence
    for(frame = 0; frame < frames; frame++)
        waitVsync();
}

void ExecuteFM()
{
    WORD octave, frame;
    
    // FM Test
    for(octave = 0; octave < 8; octave ++) {
        WORD note;
        
        for(note = 0; note < 16; note++) {
            sendZ80(Z80_PLAY_NOTE);
            
            for(frame = 0; frame < 20; frame++) {
                if(frame == 16) {
                    sendZ80(Z80_STOP_NOTE);
                }
                waitVsync();
            }
        }
    }

    sendZ80(Z80_SILENCE);
}

void ExecuteADPCMSweepsShort() {
    sendZ80(Z80_ADPCM_QHI);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_NORM);    
    WaitFrames(300);        // 5 seconds

    sendZ80(Z80_ADPCM_QLOW);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_NORM);
    WaitFrames(372);        // 6.22 seconds
    
    sendZ80(Z80_ADPCM_STOP);
}

void ExecuteADPCMSweepsLong() {
    sendZ80(Z80_ADPCM_QHI);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_LONG);
    WaitFrames(2400);       // 40 seconds

    sendZ80(Z80_ADPCM_QLOW);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_LONG);
    WaitFrames(2976);       // 49.76 seconds

    sendZ80(Z80_ADPCM_STOP);
}

void ExecuteADPCMReductions() {
    WORD count = 0;

    sendZ80(Z80_ADPCM_QHI);
    WaitFrames(4);
    for(count = 0; count < 8; count ++) {
        sendZ80Param(Z80_ADPCM_REDCT, PZ80_ADPCM_1KHI);
        WaitFrames(30);
        sendZ80(Z80_ADPCM_STOP);
        WaitFrames(2);
    }
    sendZ80(Z80_ADPCM_QLOW);
    WaitFrames(4);
    for(count = 0; count < 8; count ++) {
        sendZ80Param(Z80_ADPCM_REDCT, PZ80_ADPCM_1KLO);
        WaitFrames(30);
        sendZ80(Z80_ADPCM_STOP);
        WaitFrames(2);
    }

    sendZ80(Z80_ADPCM_STOP);
}

void MDFourier(WORD type) {
    // init the z80 and wait
    sendZ80(Z80_ADPCM_STOP);
    WaitFrames(1);
    sendZ80(Z80_INIT);
    WaitFrames(1);

    // start MDFourier
    ExecutePulseTrain();        // 20 frames
    WaitFrames(20);             // 20 frames

    // Tones
    ExecuteFM();                // 2560 frames

    // ADPCM
    if(type == MDF_ADPCM_NORM)
        ExecuteADPCMSweepsShort();
    else
        ExecuteADPCMSweepsLong();
    ExecuteADPCMReductions();

    // end MDFourier
    sendZ80(Z80_RESET_PULSE);
    WaitFrames(20);
    ExecutePulseTrain();

    sendZ80(Z80_SILENCE);
}

void MDFourierADPCMOnly(WORD type) {
    // init the z80 and wait
    sendZ80(Z80_ADPCM_STOP);
    WaitFrames(1);
    sendZ80(Z80_INIT);
    WaitFrames(1);

    // start MDFourier
    ExecutePulseTrain();        // 20 frames
    WaitFrames(20);             // 20 frames

    // ADPCM
    if(type == MDF_ADPCM_NORM)
        ExecuteADPCMSweepsShort();
    else
        ExecuteADPCMSweepsLong();
    ExecuteADPCMReductions();

    // end MDFourier
    sendZ80(Z80_RESET_PULSE);
    WaitFrames(20);
    ExecutePulseTrain();

    sendZ80(Z80_SILENCE);
}


/* main program */

int run() {
    BYTE face = 0;
    WORD x = 220, y = 100;
 
    while(1) {   
        draw(x, y, face); 

        // Wait for user Input
        if(pressedp1 & BUTTON_1) {
            clearSprites();
            MDFourier(MDF_ADPCM_NORM);
        }

        // Wait for user Input
        if(pressedp1 & BUTTON_2) {
            clearSprites();
            MDFourier(MDF_ADPCM_LONG);
        }

        if(pressedp1 & BUTTON_3) {
            clearSprites();
            MDFourierADPCMOnly(MDF_ADPCM_NORM);
        }

        if(player1 & D_UP) {
            y--;
        }

        if(player1 & D_DOWN) {
            y++;
        }

        if(player1 & D_RIGHT) {
            if(!face)
                face = 0x20;
            x++;
        }

        if(player1 & D_LEFT) {
            if(face)
                face = 0;
            x--;
        }

        waitVsync();
    }
    return 0;
}