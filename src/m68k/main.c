#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  

#define	MAXSPRITES	256
typedef struct {
    WORD	x;			// Sprite x position
    WORD	y;			// Sprite y position
    WORD	tile;		// Sprite tile
    
    // 0..4 CB[0..4] Palette ID used to render the tile
    // 5 X Flip Mirrored horizontally
    // 6 Y Flip Mirrored vertically
    // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
    // 8..11 XB[0..3] Horizontal size in tiles
    // 12..15 YB[0..3] Vertical size in tiles
    WORD	attributes;   	// Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

CPSA_REG WORD cpsa_reg[0x20] = {};
CPSB_REG WORD cpsb_reg[0x20] = {};


void setPalette(int page, int paletteID, const Palette* palette) {

    for (int j = 0 ; j < 16 ; j++) {
        palettes[paletteID].colors[j] = (*palette).colors[j];
    }
    
    // Request upload palette page to sprites
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] =  1;
    
    // Set palette base
    cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

static const Palette p = {0xF111,0xFFD9,0xFFB9,0xFE97,0xFC86,0xF965,0xF643,0xFB00,0xFFFF,0xFEEC,0xFDCA,0xFBA8,0xFA87,0xF765,0xFF00,0x0000,};

unsigned int csprite = 0;

void draw() {
    setPalette(0, 2, &p); // Upload palette to Palette 2
    Sprite* s = &sprites[0];
    s->x = 220+csprite++;
    s->y = 100;
    s->tile = 4;
    s->attributes = 2 |  5 << 12 | 3 << 8; // user Palette 2 since it is where we placed it.
    
    sprites[1].attributes = 0xFF00; // Last sprite marker
}


/* inputs */

#define _P1_INPUTS_ADDR  0x800000
#define P1_INPUT *((volatile char*)_P1_INPUTS_ADDR)

#define _P2_INPUTS_ADDR  0x800001
#define P2_INPUT *((volatile char*)_P2_INPUTS_ADDR)

#define D_RIGHT     0x01
#define D_LEFT      0x02
#define D_DOWN      0x04
#define D_UP        0x08
#define BUTTON_1    0x10
#define BUTTON_2    0x20
#define BUTTON_3    0x40


/* Z80 commands */

#define Z80_INIT        0x00
#define Z80_PULSE_ON    0x01
#define Z80_PULSE_OFF   0x02
#define Z80_RESET_PULSE 0x03
#define Z80_SILENCE     0x04
#define Z80_PLAY_NOTE   0x05
#define Z80_STOP_NOTE   0x06
#define Z80_ADPCM       0x07
#define Z80_NO_OP       0xFF

#define _Z80_LATCH1 0x800181
#define Z80_CMD *((volatile char*)_Z80_LATCH1)

void sendZ80(unsigned int cmd) {
    Z80_CMD = cmd;
}

/* Vsync handler */
volatile unsigned int vsyncActive = 0;

void onVSync() {
    vsyncActive = 1;
}

void waitVsync() {
    vsyncActive = 0;
    while(vsyncActive == 0) {
    }
}

/* MDF functions */

void ExecutePulseTrain(int channel)
{
	int f = 0;
	//Sync

	for(f = 0; f < 10; f++)
	{
        sendZ80(Z80_PULSE_ON);
		waitVsync();
        sendZ80(Z80_PULSE_OFF);
		waitVsync();
	}
}

void WaitFrames(int frames)
{
	int frame = 0;
	
	//Silence
	for(frame = 0; frame < frames; frame++)
		waitVsync();
}

void ExecuteFM()
{
	int octave, frame;
	
	// FM Test
	for(octave = 0; octave < 8; octave ++) {
		int note;
		
		for(note = 0; note < 16; note++) {
            sendZ80(Z80_PLAY_NOTE);
			
			for(frame = 0; frame < 20; frame++) {					
				if(frame == 16) {
                    sendZ80(Z80_STOP_NOTE);
				}
				waitVsync();
			}
		}
	}

    sendZ80(Z80_SILENCE);
}


/* main program */

void MDFourier() {
    // init the z80 and wait
    sendZ80(Z80_INIT);
    WaitFrames(1);

    // start MDFourier
    ExecutePulseTrain(0);
    WaitFrames(20);

    ExecuteFM();

    WaitFrames(4);
    sendZ80(Z80_ADPCM);
    WaitFrames(300);        // 5 seconds

    // end MDFourier
    sendZ80(Z80_RESET_PULSE);
    WaitFrames(20);
    ExecutePulseTrain(0);

    sendZ80(Z80_SILENCE);
}

int run() {

    // Start Z80 with NO_OP
    sendZ80(Z80_NO_OP);

    WaitFrames(100);
    MDFourier();

    draw(); 
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);


    while(1) {   
        char input = P1_INPUT;

        // Wait for user Input
        if(!(input & BUTTON_1)) {
            MDFourier();
        }

        if(!(input & BUTTON_2)) {
            sendZ80(Z80_ADPCM);
            waitVsync();
            sendZ80(Z80_RESET_PULSE);
        }

        //if(!(input & BUTTON_2)) {
            draw(); 
            cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);
        //}

        waitVsync();
    }
	return 0;
}