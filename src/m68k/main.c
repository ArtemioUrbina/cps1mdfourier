#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

#include "../z80/z80commands.h"

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  

#define GFXSCRL1    0x90c000
#define GFXSCRL1PTR ((WORD*)GFXSCRL1)
#define GFXSCRL2    0x904000
#define GFXSCRL2PTR ((WORD*)GFXSCRL2)
#define GFXSCRL3    0x908000
#define GFXSCRL3PTR ((WORD*)GFXSCRL2)
#define GFXOTHER    0x920000
#define GFXOTHERPTR ((WORD*)GFXOTHER)

#define MAXSPRITES  256
typedef struct {
    WORD    x;          // Sprite x position
    WORD    y;          // Sprite y position
    WORD    tile;       // Sprite tile
    
    // 0..4 CB[0..4] Palette ID used to render the tile
    // 5 X Flip Mirrored horizontally
    // 6 Y Flip Mirrored vertically
    // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
    // 8..11 XB[0..3] Horizontal size in tiles
    // 12..15 YB[0..3] Vertical size in tiles
    WORD    attributes;     // Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

typedef struct {
    WORD    tile;       // Sroll tile
    
    // 0 b00000000_10000000 Unused
    // 0 b00000000_01100000 Priority group ( See priority mask )
    // 0 b00000000_00010000 Y Flip
    // 0 b00000000_00001000 X Flip
    // 0 b00000000_00000111 Palette ID
    WORD    attributes;  // Tile attribute
} Scroll;

// 384x224 = 48x28 chars
//GFXRAM Scroll scroll1[48*28]  =  {};

#define Z80_CMD *((volatile BYTE*)0x800181)
#define Z80_PRM *((volatile BYTE*)0x800189)

void sendZ80(BYTE cmd) {
    Z80_CMD = cmd;
}

void sendZ80Param(BYTE cmd, BYTE param) {
    Z80_CMD = cmd;
    Z80_PRM = param;
}

CPSA_REG volatile WORD cpsa_reg[0x20] = {};
CPSB_REG volatile WORD cpsb_reg[0x20] = {};

static const Palette GrayFontPal = {
	0xf777, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0xf000, 0xfddd, 0xfccc, 0xfbbb, 0xfaaa, 0xf999, 0xf888, 0xf000
};

static const Palette Ryu = {
    0xF111, 0xFFD9, 0xFFB9, 0xFE97, 0xFC86, 0xF965, 0xF643, 0xFB00,
    0xFFFF, 0xFEEC, 0xFDCA, 0xFBA8, 0xFA87, 0xF765, 0xFF00, 0x0000
};

void LoadPalettes() {
    for(int base = 0x0; base <= 0xBF0; base += 0x10) {
        for (int j = 0 ; j < 16 ; j++) {
		    ((WORD*)palettes)[j+base] = GrayFontPal.colors[j];
        }
    }

    for (int j = 0 ; j < 16 ; j++) {
        palettes[2].colors[j] = Ryu.colors[j];
    }

    // Request upload all palettes
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] = 0x3f;
    
    // Set palette base
    cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

void draw(WORD x,WORD y, BYTE flip) {
    //setPalette(0, 2, &p); // Upload palette to Palette 2
    Sprite* s = &sprites[0];
    s->x = x;
    s->y = y;
    s->tile = 4;
    s->attributes = 2 |  5 << 12 | 3 << 8 | flip; // user Palette 2 since it is where we placed it.
    
    sprites[1].attributes = 0xFF00; // Last sprite marker
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);
}

void clearSprites() {
    sprites[0].attributes = 0xFF00; // Last sprite marker
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);
}


/* inputs */

#define _PLAYER_INPUTS_ADDR     0x800000
#define PLAYER_INPUTS *((volatile WORD*)_PLAYER_INPUTS_ADDR)

BYTE player1 = 0;
BYTE player2 = 0;
BYTE player1buf = 0;
BYTE player2buf = 0;
BYTE pressedp1 = 0;
BYTE pressedp2 = 0;

#define _DIP_SWITCH0_ADDR     0x800018
#define DIPSWITCH0 *((volatile WORD*)_DIP_SWITCH0_ADDR)
#define _DIP_SWITCH1_ADDR     0x80001A
#define DIPSWITCH1 *((volatile WORD*)_DIP_SWITCH1_ADDR)
#define _DIP_SWITCH2_ADDR     0x80001C
#define DIPSWITCH2 *((volatile WORD*)_DIP_SWITCH2_ADDR)
#define _DIP_SWITCH3_ADDR     0x80001E
#define DIPSWITCH3 *((volatile WORD*)_DIP_SWITCH3_ADDR)

BYTE dip1 = 0;
BYTE dip2 = 0;
BYTE dip3 = 0;

#define D_RIGHT     0x01
#define D_LEFT      0x02
#define D_DOWN      0x04
#define D_UP        0x08
#define BUTTON_1    0x10
#define BUTTON_2    0x20
#define BUTTON_3    0x40

void readJoysticks() {
    WORD inputs = 0;

    inputs = ~(PLAYER_INPUTS);
    player1 = inputs & 0x00FF;
    pressedp1 = player1 & ~player1buf;
    player1buf = player1;

    player2 = (inputs >> 8) & 0x00FF;
    pressedp2 = player2 & ~player2buf;
    player2buf = player2;
}

void readDIPS() {
    dip1 = (~(DIPSWITCH1) >> 8) & 0x00FF;
    dip2 = (~(DIPSWITCH2) >> 8) & 0x00FF;
    dip3 = (~(DIPSWITCH3) >> 8) & 0x00FF;
}

/* Init called before "main" (run) */

// Video register values for display
WORD rega = 0;
WORD regb = 0;

void hardwareInit() {
    readJoysticks();
    readDIPS();

    // Set Z80 latch to 0xFF so nothing will be executed
    sendZ80(Z80_NO_OP);

    // Scrolls at 0
    cpsa_reg[CPSA_REG_SCROLL1_SCROLLX] = 0;
    cpsa_reg[CPSA_REG_SCROLL1_SCROLLY] = 0;
    // Initialize CPSA&CPSB registers to the memory locations
    // sprites starts at 0x900000 in the example, Base 1, 2, 3 and
    //  other point to 0x90c000, 0x904000, 0x908000 and 0x920000
    cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);
    cpsa_reg[CPSA_REG_SCROLL1_BASE] = GFXSCRL1 >> 8;
    cpsa_reg[CPSA_REG_SCROLL2_BASE] = GFXSCRL2 >> 8;
    cpsa_reg[CPSA_REG_SCROLL3_BASE] = GFXSCRL3 >> 8;
    cpsa_reg[CPSA_REG_OTHER_BASE] = GFXOTHER >> 8;

    // 0 b00000000_00001000 Enable SCROLL1
    // 0 b00000000_00010000 Enable SCROLL2
    // 0 b00000000_00100000 Enable SCROLL3
    // 0 b00000000_00000000 Cannot control STAR1
    // 0 b00000000_00000000 Cannot control STAR2
    // 0 b00000000_11000000 Layer to draw first
    // 0 b00000011_00000000 Layer to draw second
    // 0 b00001100_00000000 Layer to draw third
    // 0 b00110000_00000000 Layer to draw last
    // Layer IDs : OBJ =0 , SCROLL1 =1 , SCROLL2 =2 , SRCOLL3 =3
    // OBJ, SCROLL 1, 2 & 3. Scroll disabled
    // 0001 0010 1100 0010
    if(pressedp1 & BUTTON_1)
        regb = ((dip1 << 8) & 0xFF00) | dip2;
    else
        regb = 0x12c2;      // 12c2
    cpsb_reg[CPSB_REG_LAYER_CTRL] = regb;

    // 0 b00000000_0000001 Enable rowscroll
    // 0 b00000000_1000000 Enable Flip Screen 90 degrees cw
    // 0011 1110
    if(pressedp1 & BUTTON_2)
        rega = 0x0000 | dip3;
    else
        rega = 0x003e;      // 3e
    cpsa_reg[CPSA_REG_VIDEOCONTROL] = rega;
    
    // 0 b00000000_00000001 Upload OBJ palette page
    // 0 b00000000_00000010 Upload SCR1 palette page
    // 0 b00000000_00000100 Upload SCR2 palette page
    // 0 b00000000_00001000 Upload SCR3 palette page
    // 0 b00000000_00010000 Upload STAR1 palette page
    // 0 b00000000_00100000 Upload STAR2 palette page
    // Upload all palettes
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] = 0x003f;

    // This array starts after sprites in GFX RAM, tell CPSA where it is
    cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

/* Vsync handler */
volatile WORD vsyncActive = 0;

void onVSync() {
    vsyncActive = 1;
    readJoysticks();
    readDIPS();
}

void waitVsync() {
    while(vsyncActive == 0);
    vsyncActive = 0;
}

/* MDF functions */

#define MDF_ADPCM_NORM  0
#define MDF_ADPCM_LONG  1

void ExecutePulseTrain()
{
    WORD f = 0;
    //Sync

    for(f = 0; f < 10; f++) {
        sendZ80(Z80_PULSE_ON);
        waitVsync();
        sendZ80(Z80_PULSE_OFF);
        waitVsync();
    }
}

void WaitFrames(WORD frames)
{
    WORD frame = 0;
    
    //Silence
    for(frame = 0; frame < frames; frame++)
        waitVsync();
}

void ExecuteFM()
{
    WORD octave, frame;
    
    // FM Test
    for(octave = 0; octave < 8; octave ++) {
        WORD note;
        
        for(note = 0; note < 16; note++) {
            sendZ80(Z80_PLAY_NOTE);
            
            for(frame = 0; frame < 20; frame++) {
                if(frame == 16) {
                    sendZ80(Z80_STOP_NOTE);
                }
                waitVsync();
            }
        }
    }

    sendZ80(Z80_SILENCE);
}

void ExecuteADPCMSweepsShort() {
    sendZ80(Z80_ADPCM_QHI);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_NORM);    
    WaitFrames(300);        // 5 seconds

    sendZ80(Z80_ADPCM_QLOW);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_NORM);
    WaitFrames(372);        // 6.22 seconds
    
    sendZ80(Z80_ADPCM_STOP);
}

void ExecuteADPCMSweepsLong() {
    sendZ80(Z80_ADPCM_QHI);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_LONG);
    WaitFrames(2400);       // 40 seconds

    sendZ80(Z80_ADPCM_QLOW);
    WaitFrames(4);
    sendZ80Param(Z80_ADPCM_PLAY, PZ80_ADPCM_LONG);
    WaitFrames(2976);       // 49.76 seconds

    sendZ80(Z80_ADPCM_STOP);
}

void ExecuteADPCMReductions() {
    WORD count = 0;

    sendZ80(Z80_ADPCM_QHI);
    WaitFrames(4);
    for(count = 0; count < 8; count ++) {
        sendZ80Param(Z80_ADPCM_REDCT, PZ80_ADPCM_1KHI);
        WaitFrames(30);
        sendZ80(Z80_ADPCM_STOP);
        WaitFrames(2);
    }
    sendZ80(Z80_ADPCM_QLOW);
    WaitFrames(4);
    for(count = 0; count < 8; count ++) {
        sendZ80Param(Z80_ADPCM_REDCT, PZ80_ADPCM_1KLO);
        WaitFrames(30);
        sendZ80(Z80_ADPCM_STOP);
        WaitFrames(2);
    }

    sendZ80(Z80_ADPCM_STOP);
}

void MDFourier(WORD type) {
    // init the z80 and wait
    sendZ80(Z80_ADPCM_STOP);
    WaitFrames(1);
    sendZ80(Z80_INIT);
    WaitFrames(1);

    // start MDFourier
    ExecutePulseTrain();        // 20 frames
    WaitFrames(20);             // 20 frames

    // Tones
    ExecuteFM();                // 2560 frames

    // ADPCM
    if(type == MDF_ADPCM_NORM)
        ExecuteADPCMSweepsShort();
    else
        ExecuteADPCMSweepsLong();
    ExecuteADPCMReductions();

    // end MDFourier
    sendZ80(Z80_RESET_PULSE);
    WaitFrames(20);
    ExecutePulseTrain();

    sendZ80(Z80_SILENCE);
}

void MDFourierADPCMOnly(WORD type) {
    // init the z80 and wait
    sendZ80(Z80_ADPCM_STOP);
    WaitFrames(1);
    sendZ80(Z80_INIT);
    WaitFrames(1);

    // start MDFourier
    ExecutePulseTrain();        // 20 frames
    WaitFrames(20);             // 20 frames

    // ADPCM
    if(type == MDF_ADPCM_NORM)
        ExecuteADPCMSweepsShort();
    else
        ExecuteADPCMSweepsLong();
    ExecuteADPCMReductions();

    // end MDFourier
    sendZ80(Z80_RESET_PULSE);
    WaitFrames(20);
    ExecutePulseTrain();

    sendZ80(Z80_SILENCE);
}

/* text */

/*
Drawing SCROLLs
Rendering tilemaps is much like rendering OBJs. Descriptors must be written to the
GFX RAM but the layout is much simpler. Each entry is two 16-bit WORDs wide (four
bytes).
SCROLL entry layout : xxxx aaaa
xxxx = tileID
aaaa = attributes
The attribute WORD is a bit field where we find in particular the palette ID, the group ID
which references the priority mask, and the usual X/Y flippers.
0 b00000000_10000000 Unused
0 b00000000_01100000 Priority group ( See priority mask )
0 b00000000_00010000 Y Flip
0 b00000000_00001000 X Flip
0 b00000000_00000111 Palette ID
All SCROLLs have different size and tile size but they are all considered Sprites (with
rectangular dimensions). They all feature 64x64 (4,096) entries
*/

// 384x224 = 48x28 chars
// chars are 32 bits and row/column are reversed (column-major)
void writeText(WORD x, WORD y, const char* s) {
    WORD *tilemap = GFXSCRL1PTR;

	x += 8; // compensate for screen scroll.
	y += 2;
    y *= 2;
	
	for (;;)
	{
		char c = *s++;
		if (!c)
			break;
		WORD* pChar = &tilemap[(x++* 64 + y)]; // swizzling here is weird (and will wrap)
		*pChar = 0x4000 | c; // tileID, 0x4000 is for sf2ud
		//*pChar++ = 0x0; // Palette ID, they are all set to 0 in crt0.s
	}
}

void cleartext() {
    WORD* tilemap1 = (WORD*)0x90c000;
	
    for (WORD y = 2; y < 28+2; y++)
    {
	    for (WORD x = 8; x < 48+8; x++)
	    {
		    WORD* pChar = &tilemap1[(x * 64 + y * 2)]; // swizzling here is weird (and will wrap)
		    *pChar = 0x0000; // tileID, 0x4000 is for sf2ud, ROM offset is 0x10000
		    //*pChar++ = 0x0; // Palette ID
	    }
    }
}

void printDIPs(WORD x, WORD y) {
    int pos = 0, originalX = 0;
	WORD* tilemap = GFXSCRL1PTR;

    x += 8; // compensate for screen scroll.
	y += 2;
    y *= 2;

    originalX = x;
	    
    for (pos = 0; pos < 8; pos++)
	{
		WORD* pChar = &tilemap[(x++* 64 + y)]; // swizzling here is weird (and will wrap)
        if(dip1 & (1 << pos))
		    *pChar = 0x4031;
        else
            *pChar = 0x4030;
		//*pChar++ = 0x0; // Palette ID
	}

    x = originalX;
    y += 4;

    for (pos = 0; pos < 8; pos++)
	{
		WORD* pChar = &tilemap[(x++* 64 + y)]; // swizzling here is weird (and will wrap)
        if(dip2 & (1 << pos))
		    *pChar = 0x4031;
        else
            *pChar = 0x4030;
		//*pChar++ = 0x0; // Palette ID
	}

    x = originalX;
    y+= 4;

    for (pos = 0; pos < 8; pos++)
	{
		WORD* pChar = &tilemap[(x++* 64 + y)]; // swizzling here is weird (and will wrap)
        if(dip3 & (1 << pos))
		    *pChar = 0x4031;
        else
            *pChar = 0x4030;
		//*pChar++ = 0x0; // Palette ID
	}
}

void printRegs(WORD x, WORD y) {
	WORD* tilemap1 = (WORD*)0x90c000;
    int pos = 0, ox = 0;

	x += 8; // compensate for screen scroll.
	y += 2;

    ox = x;
    y *= 2;
	
    for (pos = 15; pos >= 0; pos--) {
		WORD* pChar = &tilemap1[(x++* 64 + y)];
        if(regb & (1 << pos))
		    *pChar = 0x4031;
        else
            *pChar = 0x4030;
	}

    x = ox;
    y += 4;

    for (pos = 15; pos >= 0; pos--) {
		WORD* pChar = &tilemap1[(x++* 64 + y)];
        if(rega & (1 << pos))
		    *pChar = 0x4031;
        else
            *pChar = 0x4030;
	}
}

/* main program */

int run() {
    BYTE face = 0, drawText = 1;
    WORD x = 220, y = 100;

    LoadPalettes();
    printRegs(30, 16);

    while(1) {
        if(drawText) {
            writeText(6,  6, "Button 1 for MDF YM2151 + short ADPCM");
            writeText(6,  8, "Button 2 for MDF YM2151 + long ADPCM");
            writeText(6, 10, "Button 3 for MDF just ADPCM");
            drawText = 0;
        }

        printDIPs(34, 20);
        draw(x, y, face); 

        // Wait for user Input
        if(pressedp1 & BUTTON_1) {
            clearSprites();
            cleartext();
            MDFourier(MDF_ADPCM_NORM);
            drawText = 1;
        }

        // Wait for user Input
        if(pressedp1 & BUTTON_2) {
            clearSprites();
            cleartext();
            MDFourier(MDF_ADPCM_LONG);
            drawText = 1;
        }

        if(pressedp1 & BUTTON_3) {
            clearSprites();
            cleartext();
            MDFourierADPCMOnly(MDF_ADPCM_NORM);
            drawText = 1;
        }

        if(player1 & D_UP) {
            y--;
        }

        if(player1 & D_DOWN) {
            y++;
        }

        if(player1 & D_RIGHT) {
            if(!face)
                face = 0x20;
            x++;
        }

        if(player1 & D_LEFT) {
            if(face)
                face = 0;
            x--;
        }

        waitVsync();
    }
    return 0;
}