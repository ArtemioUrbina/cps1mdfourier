#include "ccps_gfx.h" // Contains all GFX data structures
#include "gfx.h" // This is auto-generated by GFX assets
#include "cpsa.h" // This is auto-generated
#include "cpsb.h" // This is auto-gemerated

// https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html
// https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html
// https://mcuoneclipse.com/2016/11/01/getting-the-memory-range-of-sections-with-gnu-linker-files/

#define GFXRAM   __attribute__ ((section (".gfx_data")))

#define CPSA_REG __attribute__ ((section (".cpsa_reg")))  
#define CPSB_REG __attribute__ ((section (".cpsb_reg")))  

#define MAXSPRITES  256
typedef struct {
    WORD    x;          // Sprite x position
    WORD    y;          // Sprite y position
    WORD    tile;       // Sprite tile
    
    // 0..4 CB[0..4] Palette ID used to render the tile
    // 5 X Flip Mirrored horizontally
    // 6 Y Flip Mirrored vertically
    // 7 LOOKUP Looks up the CB value into the RAM for each tile (see later section)
    // 8..11 XB[0..3] Horizontal size in tiles
    // 12..15 YB[0..3] Vertical size in tiles
    WORD    attributes;     // Sprite attribute
} Sprite;

// TODO __attribute__ ((aligned (0xFF))) ?
GFXRAM Sprite sprites [MAXSPRITES]  =  {};


// TODO allow multiple pages, right now there is only
//      enough space for one page (we need 6 for obj, scr1,2,3, and star1,2)
// TODO __attribute__ ((aligned ( 0x400))) ?
GFXRAM Palette palettes[32];

CPSA_REG WORD cpsa_reg[0x20] = {};
CPSB_REG WORD cpsb_reg[0x20] = {};


void setPalette(int page, int paletteID, const Palette* palette) {

    for (int j = 0 ; j < 16 ; j++) {
        palettes[paletteID].colors[j] = (*palette).colors[j];
    }
    
    // Request upload palette page to sprites
    cpsb_reg[CPSB_REG_PALETTE_CONTROL] =  1;
    
    // Set palette base
    cpsa_reg[CPSA_REG_PALETTE_BASE] = (WORD)(((DWORD)palettes) >> 8);
}

static const Palette p = {0xF111,0xFFD9,0xFFB9,0xFE97,0xFC86,0xF965,0xF643,0xFB00,0xFFFF,0xFEEC,0xFDCA,0xFBA8,0xFA87,0xF765,0xFF00,0x0000,};


void draw(WORD x,WORD y) {
    setPalette(0, 2, &p); // Upload palette to Palette 2
    Sprite* s = &sprites[0];
    s->x = x;
    s->y = y;
    s->tile = 4;
    s->attributes = 2 |  5 << 12 | 3 << 8; // user Palette 2 since it is where we placed it.
    
    sprites[1].attributes = 0xFF00; // Last sprite marker
}


/* inputs */

#define _PLAYER_INPUTS_ADDR  0x800000
#define PLAYER_INPUTS *((volatile WORD*)_PLAYER_INPUTS_ADDR)
BYTE player1 = 0;
BYTE player2 = 0;

#define D_RIGHT     0x01
#define D_LEFT      0x02
#define D_DOWN      0x04
#define D_UP        0x08
#define BUTTON_1    0x10
#define BUTTON_2    0x20
#define BUTTON_3    0x40

void readJoysticks() {
    int inputs = 0;

    inputs = ~(PLAYER_INPUTS);
    player1 = inputs & 0x00FF;
    player2 = (inputs >> 8) & 0x00FF;
}


/* Z80 commands */

#define Z80_INIT        0x00
#define Z80_PULSE_ON    0x01
#define Z80_PULSE_OFF   0x02
#define Z80_RESET_PULSE 0x03
#define Z80_SILENCE     0x04
#define Z80_PLAY_NOTE   0x05
#define Z80_STOP_NOTE   0x06
#define Z80_ADPCM       0x07
#define Z80_NO_OP       0xFF

#define _Z80_LATCH1 0x800181
#define Z80_CMD *((volatile BYTE*)_Z80_LATCH1)

void sendZ80(BYTE cmd) {
    Z80_CMD = cmd;
}

/* Vsync handler */
volatile WORD vsyncActive = 0;

void onVSync() {
    vsyncActive = 1;
    readJoysticks();
}

void waitVsync() {
    vsyncActive = 0;
    while(vsyncActive == 0) {
    }
}

/* MDF functions */

void ExecutePulseTrain()
{
    WORD f = 0;
    //Sync

    for(f = 0; f < 10; f++)
    {
        sendZ80(Z80_PULSE_ON);
        waitVsync();
        sendZ80(Z80_PULSE_OFF);
        waitVsync();
    }
}

void WaitFrames(WORD frames)
{
    WORD frame = 0;
    
    //Silence
    for(frame = 0; frame < frames; frame++)
        waitVsync();
}

void ExecuteFM()
{
    WORD octave, frame;
    
    // FM Test
    for(octave = 0; octave < 8; octave ++) {
        WORD note;
        
        for(note = 0; note < 16; note++) {
            sendZ80(Z80_PLAY_NOTE);
            
            for(frame = 0; frame < 20; frame++) {
                if(frame == 16) {
                    sendZ80(Z80_STOP_NOTE);
                }
                waitVsync();
            }
        }
    }

    sendZ80(Z80_SILENCE);
}


/* main program */

void MDFourier() {
    // init the z80 and wait
    sendZ80(Z80_INIT);
    WaitFrames(1);

    // start MDFourier
    ExecutePulseTrain();
    WaitFrames(20);

    ExecuteFM();

    WaitFrames(4);
    sendZ80(Z80_ADPCM);
    WaitFrames(300);        // 5 seconds

    // end MDFourier
    sendZ80(Z80_RESET_PULSE);
    WaitFrames(20);
    ExecutePulseTrain();

    sendZ80(Z80_SILENCE);
}

int run() {
    WORD x = 220, y = 100;
    // Start Z80 with NO_OP
    sendZ80(Z80_NO_OP);

    while(1) {   
        draw(x, y); 
        cpsa_reg[CPSA_REG_SPRITES_BASE] = (WORD)(((DWORD)sprites) >> 8);

        // Wait for user Input
        if(player1 & BUTTON_1) {
            MDFourier();
        }

        if(player1 & BUTTON_2) {
            sendZ80(Z80_ADPCM);
            waitVsync();
            sendZ80(Z80_RESET_PULSE);
        }

        if(player1 & BUTTON_3) {
            x = 220;
            y = 100;
        }

        if(player1 & D_UP) {
            y--;
        }

        if(player1 & D_DOWN) {
            y++;
        }

        if(player1 & D_RIGHT) {
            x++;
        }

        if(player1 & D_LEFT) {
            x--;
        }

        waitVsync();
    }
    return 0;
}